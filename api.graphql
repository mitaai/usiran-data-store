### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AB_uniqueCompoundUniqueInput {
  A: String!
  B: String!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type BriefingBookDocument {
  A: String!
  B: String!
  id: String!
}

input BriefingBookDocumentFilter {
  every: BriefingBookDocumentWhereInput
  none: BriefingBookDocumentWhereInput
  some: BriefingBookDocumentWhereInput
}

input BriefingBookDocumentWhereInput {
  A: StringFilter
  AND: [BriefingBookDocumentWhereInput!]
  B: StringFilter
  BriefingBook: BriefingBookWhereInput
  Document: DocumentWhereInput
  id: StringFilter
  NOT: [BriefingBookDocumentWhereInput!]
  OR: [BriefingBookDocumentWhereInput!]
}

type BriefingBookEvent {
  A: String!
  B: String!
  id: String!
}

input BriefingBookEventFilter {
  every: BriefingBookEventWhereInput
  none: BriefingBookEventWhereInput
  some: BriefingBookEventWhereInput
}

input BriefingBookEventWhereInput {
  A: StringFilter
  AND: [BriefingBookEventWhereInput!]
  B: StringFilter
  BriefingBook: BriefingBookWhereInput
  Event: EventWhereInput
  id: StringFilter
  NOT: [BriefingBookEventWhereInput!]
  OR: [BriefingBookEventWhereInput!]
}

input BriefingBookWhereInput {
  AND: [BriefingBookWhereInput!]
  briefingBookDescription: NullableStringFilter
  briefingBookTitle: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  mentionedDocuments: BriefingBookDocumentFilter
  mentionedEvents: BriefingBookEventFilter
  mentionedStakeholders: StakeholderBriefingBookFilter
  NOT: [BriefingBookWhereInput!]
  OR: [BriefingBookWhereInput!]
  updatedAt: DateTimeFilter
}

type ClassificationOnDocument {
  A: String!
  B: String!
  id: String!
}

input ClassificationOnDocumentFilter {
  every: ClassificationOnDocumentWhereInput
  none: ClassificationOnDocumentWhereInput
  some: ClassificationOnDocumentWhereInput
}

input ClassificationOnDocumentWhereInput {
  A: StringFilter
  AND: [ClassificationOnDocumentWhereInput!]
  B: StringFilter
  Classification: ClassificationWhereInput
  Document: DocumentWhereInput
  id: StringFilter
  NOT: [ClassificationOnDocumentWhereInput!]
  OR: [ClassificationOnDocumentWhereInput!]
}

input ClassificationOnDocumentWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input ClassificationWhereInput {
  AND: [ClassificationWhereInput!]
  createdAt: DateTimeFilter
  documentsWithClassification: ClassificationOnDocumentFilter
  id: StringFilter
  name: StringFilter
  NOT: [ClassificationWhereInput!]
  OR: [ClassificationWhereInput!]
  updatedAt: DateTimeFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Document {
  documentAuthors(after: DocumentAuthorWhereUniqueInput, before: DocumentAuthorWhereUniqueInput, first: Int, last: Int): [DocumentAuthor!]!
  documentClassification(after: ClassificationOnDocumentWhereUniqueInput, before: ClassificationOnDocumentWhereUniqueInput, first: Int, last: Int): [ClassificationOnDocument!]!
  documentCreationDate: DateTime
  documentDescription: String
  documentFiles(after: DocumentFileWhereUniqueInput, before: DocumentFileWhereUniqueInput, first: Int, last: Int): [DocumentFile!]!
  documentKind(after: KindOnDocumentWhereUniqueInput, before: KindOnDocumentWhereUniqueInput, first: Int, last: Int): [KindOnDocument!]!
  documentOriginalID: String!
  documentPublicationDate: DateTime
  documentTags(after: TagOnDocumentWhereUniqueInput, before: TagOnDocumentWhereUniqueInput, first: Int, last: Int): [TagOnDocument!]!
  documentTitle: String!
  documentTranscript: String
  id: String!
  mentionedLocations(after: DocumentLocationWhereUniqueInput, before: DocumentLocationWhereUniqueInput, first: Int, last: Int): [DocumentLocation!]!
  mentionedStakeholders(after: DocumentInvolvedStakeholderWhereUniqueInput, before: DocumentInvolvedStakeholderWhereUniqueInput, first: Int, last: Int): [DocumentInvolvedStakeholder!]!
}

type DocumentAuthor {
  A: String!
  B: String!
  id: String!
}

input DocumentAuthorFilter {
  every: DocumentAuthorWhereInput
  none: DocumentAuthorWhereInput
  some: DocumentAuthorWhereInput
}

input DocumentAuthorWhereInput {
  A: StringFilter
  AND: [DocumentAuthorWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  id: StringFilter
  NOT: [DocumentAuthorWhereInput!]
  OR: [DocumentAuthorWhereInput!]
  Stakeholder: StakeholderWhereInput
}

input DocumentAuthorWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

type DocumentEvent {
  A: String!
  B: String!
  id: String!
}

input DocumentEventFilter {
  every: DocumentEventWhereInput
  none: DocumentEventWhereInput
  some: DocumentEventWhereInput
}

input DocumentEventWhereInput {
  A: StringFilter
  AND: [DocumentEventWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  Event: EventWhereInput
  id: StringFilter
  NOT: [DocumentEventWhereInput!]
  OR: [DocumentEventWhereInput!]
}

type DocumentFile {
  A: String!
  B: String!
  id: String!
}

input DocumentFileFilter {
  every: DocumentFileWhereInput
  none: DocumentFileWhereInput
  some: DocumentFileWhereInput
}

input DocumentFileWhereInput {
  A: StringFilter
  AND: [DocumentFileWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  File: FileWhereInput
  id: StringFilter
  NOT: [DocumentFileWhereInput!]
  OR: [DocumentFileWhereInput!]
}

input DocumentFileWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

type DocumentInvolvedStakeholder {
  A: String!
  B: String!
  id: String!
}

input DocumentInvolvedStakeholderFilter {
  every: DocumentInvolvedStakeholderWhereInput
  none: DocumentInvolvedStakeholderWhereInput
  some: DocumentInvolvedStakeholderWhereInput
}

input DocumentInvolvedStakeholderWhereInput {
  A: StringFilter
  AND: [DocumentInvolvedStakeholderWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  id: StringFilter
  NOT: [DocumentInvolvedStakeholderWhereInput!]
  OR: [DocumentInvolvedStakeholderWhereInput!]
  Stakeholder: StakeholderWhereInput
}

input DocumentInvolvedStakeholderWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

type DocumentLocation {
  A: String!
  B: String!
  id: String!
}

input DocumentLocationFilter {
  every: DocumentLocationWhereInput
  none: DocumentLocationWhereInput
  some: DocumentLocationWhereInput
}

input DocumentLocationWhereInput {
  A: StringFilter
  AND: [DocumentLocationWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  id: StringFilter
  Location: LocationWhereInput
  NOT: [DocumentLocationWhereInput!]
  OR: [DocumentLocationWhereInput!]
}

input DocumentLocationWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input DocumentOrderByInput {
  createdAt: OrderByArg
  dnsaAbstract: OrderByArg
  dnsaCitation: OrderByArg
  dnsaCollection: OrderByArg
  dnsaFrom: OrderByArg
  dnsaItemNumber: OrderByArg
  dnsaOrigin: OrderByArg
  dnsaStakeholder: OrderByArg
  dnsaSubject: OrderByArg
  dnsaTo: OrderByArg
  dnsaURL: OrderByArg
  documentCreationDate: OrderByArg
  documentDescription: OrderByArg
  documentMediaType: OrderByArg
  documentOriginalID: OrderByArg
  documentPublicationDate: OrderByArg
  documentTitle: OrderByArg
  documentTranscript: OrderByArg
  id: OrderByArg
  sessionNumber: OrderByArg
  updatedAt: OrderByArg
}

input DocumentWhereInput {
  AND: [DocumentWhereInput!]
  briefingBooksMentionedIn: BriefingBookDocumentFilter
  createdAt: DateTimeFilter
  dnsaAbstract: NullableStringFilter
  dnsaCitation: NullableStringFilter
  dnsaCollection: NullableStringFilter
  dnsaFrom: NullableStringFilter
  dnsaItemNumber: NullableStringFilter
  dnsaOrigin: NullableStringFilter
  dnsaStakeholder: NullableStringFilter
  dnsaSubject: NullableStringFilter
  dnsaTo: NullableStringFilter
  dnsaURL: NullableStringFilter
  documentAuthors: DocumentAuthorFilter
  documentClassification: ClassificationOnDocumentFilter
  documentCreationDate: NullableDateTimeFilter
  documentDescription: NullableStringFilter
  documentFiles: DocumentFileFilter
  documentKind: KindOnDocumentFilter
  documentMediaType: StringFilter
  documentOriginalID: StringFilter
  documentPublicationDate: NullableDateTimeFilter
  documentTags: TagOnDocumentFilter
  documentTitle: StringFilter
  documentTranscript: NullableStringFilter
  id: StringFilter
  mentionedEvents: DocumentEventFilter
  mentionedLocations: DocumentLocationFilter
  mentionedStakeholders: DocumentInvolvedStakeholderFilter
  NOT: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  sessionNumber: NullableIntFilter
  updatedAt: DateTimeFilter
}

input DocumentWhereUniqueInput {
  id: String
}

type Event {
  eventDescription: String
  eventLocations(after: LocationOnEventWhereUniqueInput, before: LocationOnEventWhereUniqueInput, first: Int, last: Int): [LocationOnEvent!]!
  eventStakeholders(after: StakeholderEventWhereUniqueInput, before: StakeholderEventWhereUniqueInput, first: Int, last: Int): [StakeholderEvent!]!
  eventStartDate: DateTime!
  eventTags(after: TagOnEventWhereUniqueInput, before: TagOnEventWhereUniqueInput, first: Int, last: Int): [TagOnEvent!]!
  eventTitle: String!
  id: String!
}

input EventOrderByInput {
  createdAt: OrderByArg
  eventDescription: OrderByArg
  eventEndDate: OrderByArg
  eventStartDate: OrderByArg
  eventTitle: OrderByArg
  id: OrderByArg
  updatedAt: OrderByArg
}

input EventWhereInput {
  AND: [EventWhereInput!]
  briefingBooksMentionedIn: BriefingBookEventFilter
  createdAt: DateTimeFilter
  documentsMentionedIn: DocumentEventFilter
  eventDescription: NullableStringFilter
  eventEndDate: NullableDateTimeFilter
  eventLocations: LocationOnEventFilter
  eventStakeholders: StakeholderEventFilter
  eventStartDate: DateTimeFilter
  eventTags: TagOnEventFilter
  eventTitle: StringFilter
  id: StringFilter
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  updatedAt: DateTimeFilter
}

input EventWhereUniqueInput {
  id: String
}

type File {
  id: String!
  url: String!
}

input FileOrderByInput {
  contentType: OrderByArg
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  secret: OrderByArg
  size: OrderByArg
  updatedAt: OrderByArg
  url: OrderByArg
}

input FileWhereInput {
  AND: [FileWhereInput!]
  contentType: StringFilter
  createdAt: DateTimeFilter
  documentsIncludedIn: DocumentFileFilter
  id: StringFilter
  name: StringFilter
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  secret: StringFilter
  size: IntFilter
  updatedAt: DateTimeFilter
  url: StringFilter
}

input FileWhereUniqueInput {
  id: String
  secret: String
  url: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type KindOnDocument {
  A: String!
  B: String!
  id: String!
}

input KindOnDocumentFilter {
  every: KindOnDocumentWhereInput
  none: KindOnDocumentWhereInput
  some: KindOnDocumentWhereInput
}

input KindOnDocumentWhereInput {
  A: StringFilter
  AND: [KindOnDocumentWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  id: StringFilter
  Kind: KindWhereInput
  NOT: [KindOnDocumentWhereInput!]
  OR: [KindOnDocumentWhereInput!]
}

input KindOnDocumentWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input KindWhereInput {
  AND: [KindWhereInput!]
  createdAt: DateTimeFilter
  documentsWithKind: KindOnDocumentFilter
  id: StringFilter
  name: StringFilter
  NOT: [KindWhereInput!]
  OR: [KindWhereInput!]
  updatedAt: DateTimeFilter
}

type Location {
  documentsMentionedIn(after: DocumentLocationWhereUniqueInput, before: DocumentLocationWhereUniqueInput, first: Int, last: Int): [DocumentLocation!]!
  id: String!
  locationDescription: String
  locationEvents(after: LocationOnEventWhereUniqueInput, before: LocationOnEventWhereUniqueInput, first: Int, last: Int): [LocationOnEvent!]!
  locationName: String!
  locationWikipediaUri: String
}

type LocationOnEvent {
  A: String!
  B: String!
  id: String!
}

input LocationOnEventFilter {
  every: LocationOnEventWhereInput
  none: LocationOnEventWhereInput
  some: LocationOnEventWhereInput
}

input LocationOnEventWhereInput {
  A: StringFilter
  AND: [LocationOnEventWhereInput!]
  B: StringFilter
  Event: EventWhereInput
  id: StringFilter
  Location: LocationWhereInput
  NOT: [LocationOnEventWhereInput!]
  OR: [LocationOnEventWhereInput!]
}

input LocationOnEventWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input LocationOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  locationDescription: OrderByArg
  locationLatitude: OrderByArg
  locationLongitude: OrderByArg
  locationName: OrderByArg
  locationWikipediaUri: OrderByArg
  updatedAt: OrderByArg
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  createdAt: DateTimeFilter
  documentsMentionedIn: DocumentLocationFilter
  id: StringFilter
  locationDescription: NullableStringFilter
  locationEvents: LocationOnEventFilter
  locationLatitude: NullableIntFilter
  locationLongitude: NullableIntFilter
  locationName: StringFilter
  locationWikipediaUri: NullableStringFilter
  NOT: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  updatedAt: DateTimeFilter
}

input LocationWhereUniqueInput {
  id: String
  locationName: String
}

type Mutation {
  createOneUser(data: UserCreateInput!): User!
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  document(where: DocumentWhereUniqueInput!): Document
  documents(after: DocumentWhereUniqueInput, before: DocumentWhereUniqueInput, first: Int, last: Int, orderBy: DocumentOrderByInput, where: DocumentWhereInput): [Document!]!
  event(where: EventWhereUniqueInput!): Event
  events(after: EventWhereUniqueInput, before: EventWhereUniqueInput, first: Int, last: Int, orderBy: EventOrderByInput, where: EventWhereInput): [Event!]!
  file(where: FileWhereUniqueInput!): File
  files(after: FileWhereUniqueInput, before: FileWhereUniqueInput, first: Int, last: Int, orderBy: FileOrderByInput, where: FileWhereInput): [File!]!
  location(where: LocationWhereUniqueInput!): Location
  locations(after: LocationWhereUniqueInput, before: LocationWhereUniqueInput, first: Int, last: Int, orderBy: LocationOrderByInput, where: LocationWhereInput): [Location!]!
  stakeholder(where: StakeholderWhereUniqueInput!): Stakeholder
  stakeholders(after: StakeholderWhereUniqueInput, before: StakeholderWhereUniqueInput, first: Int, last: Int, orderBy: StakeholderOrderByInput, where: QueryStakeholdersWhereInput): [Stakeholder!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, where: UserWhereInput): [User!]!
}

input QueryStakeholdersWhereInput {
  id: StringFilter
}

type Stakeholder {
  documents(after: DocumentAuthorWhereUniqueInput, before: DocumentAuthorWhereUniqueInput, first: Int, last: Int): [DocumentAuthor!]!
  documentsMentionedIn(after: DocumentInvolvedStakeholderWhereUniqueInput, before: DocumentInvolvedStakeholderWhereUniqueInput, first: Int, last: Int): [DocumentInvolvedStakeholder!]!
  eventsInvolvedIn(after: StakeholderEventWhereUniqueInput, before: StakeholderEventWhereUniqueInput, first: Int, last: Int): [StakeholderEvent!]!
  id: String!
  stakeholderDescription: String
  stakeholderFullName: String!
  stakeholderWikipediaUri: String
}

type StakeholderBriefingBook {
  A: String!
  B: String!
  id: String!
}

input StakeholderBriefingBookFilter {
  every: StakeholderBriefingBookWhereInput
  none: StakeholderBriefingBookWhereInput
  some: StakeholderBriefingBookWhereInput
}

input StakeholderBriefingBookWhereInput {
  A: StringFilter
  AND: [StakeholderBriefingBookWhereInput!]
  B: StringFilter
  BriefingBook: BriefingBookWhereInput
  id: StringFilter
  NOT: [StakeholderBriefingBookWhereInput!]
  OR: [StakeholderBriefingBookWhereInput!]
  Stakeholder: StakeholderWhereInput
}

type StakeholderEvent {
  A: String!
  B: String!
  id: String!
}

input StakeholderEventFilter {
  every: StakeholderEventWhereInput
  none: StakeholderEventWhereInput
  some: StakeholderEventWhereInput
}

input StakeholderEventWhereInput {
  A: StringFilter
  AND: [StakeholderEventWhereInput!]
  B: StringFilter
  Event: EventWhereInput
  id: StringFilter
  NOT: [StakeholderEventWhereInput!]
  OR: [StakeholderEventWhereInput!]
  Stakeholder: StakeholderWhereInput
}

input StakeholderEventWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input StakeholderOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  isStakeholderInstitution: OrderByArg
  stakeholderDescription: OrderByArg
  stakeholderFullName: OrderByArg
  stakeholderWikipediaUri: OrderByArg
  updatedAt: OrderByArg
}

input StakeholderWhereInput {
  AND: [StakeholderWhereInput!]
  briefingBooksMentionedIn: StakeholderBriefingBookFilter
  createdAt: DateTimeFilter
  documents: DocumentAuthorFilter
  documentsMentionedIn: DocumentInvolvedStakeholderFilter
  eventsInvolvedIn: StakeholderEventFilter
  id: StringFilter
  isStakeholderInstitution: BooleanFilter
  NOT: [StakeholderWhereInput!]
  OR: [StakeholderWhereInput!]
  stakeholderDescription: NullableStringFilter
  stakeholderFullName: StringFilter
  stakeholderWikipediaUri: NullableStringFilter
  updatedAt: DateTimeFilter
}

input StakeholderWhereUniqueInput {
  id: String
  stakeholderFullName: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type TagOnDocument {
  A: String!
  B: String!
  id: String!
}

input TagOnDocumentFilter {
  every: TagOnDocumentWhereInput
  none: TagOnDocumentWhereInput
  some: TagOnDocumentWhereInput
}

input TagOnDocumentWhereInput {
  A: StringFilter
  AND: [TagOnDocumentWhereInput!]
  B: StringFilter
  Document: DocumentWhereInput
  id: StringFilter
  NOT: [TagOnDocumentWhereInput!]
  OR: [TagOnDocumentWhereInput!]
  Tag: TagWhereInput
}

input TagOnDocumentWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

type TagOnEvent {
  A: String!
  B: String!
  id: String!
}

input TagOnEventFilter {
  every: TagOnEventWhereInput
  none: TagOnEventWhereInput
  some: TagOnEventWhereInput
}

input TagOnEventWhereInput {
  A: StringFilter
  AND: [TagOnEventWhereInput!]
  B: StringFilter
  Event: EventWhereInput
  id: StringFilter
  NOT: [TagOnEventWhereInput!]
  OR: [TagOnEventWhereInput!]
  Tag: TagWhereInput
}

input TagOnEventWhereUniqueInput {
  A: String
  AB_unique: AB_uniqueCompoundUniqueInput
  B: String
  id: String
}

input TagWhereInput {
  AND: [TagWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  documentsWithTag: TagOnDocumentFilter
  eventsWithTag: TagOnEventFilter
  id: StringFilter
  name: StringFilter
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  tagWikipediaUri: NullableStringFilter
  type: NullableStringFilter
  updatedAt: DateTimeFilter
}

type User {
  createdAt: DateTime!
  email: String
  firstName: String
  id: String!
  lastName: String
  role: String
  updatedAt: DateTime!
  userName: String!
}

input UserCreateInput {
  createdAt: DateTime
  email: String
  firstName: String
  id: String!
  lastName: String
  password: String
  role: String
  updatedAt: DateTime
  userName: String!
}

input UserOrderByInput {
  createdAt: OrderByArg
  email: OrderByArg
  firstName: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  password: OrderByArg
  role: OrderByArg
  updatedAt: OrderByArg
  userName: OrderByArg
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: String
  updatedAt: DateTime
  userName: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: NullableStringFilter
  firstName: NullableStringFilter
  id: StringFilter
  lastName: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: NullableStringFilter
  role: NullableStringFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  userName: String
}
